
We have a problem.  Four bytes are indeed inserted, but
are all 0x00.  And the original bytes 13-14, where
EtherType normally is but should be the 802.1Q TPID
of 0x8100 when a tag is present, hold the same value
for EtherType as the non-tagged packet.

Semantics for copy_header, push, pop, and/or modify_field
must be verified.  Procedure:
1 - Use copy_header(ext_cpy[n], ext[n]) for n = 0 to 19
2 - Check whether ext_cpy[14] and higher are valid; they
    shouldn't be
3 - Push 8 elements into ext_cpy
4 - Pop 8 elements from ext_cpy
5 - Check whether ext_cpy[12] and higher are valid; they
    shouldn't be
    Note: should do two versions of 3-5:
    a. push and pop in the same table/action
    b. push and pop in separate tables/actions
6 - Pop 12 elements from ext
7 - Push 4 elements into ext
8 - modify_field(ext[n], val) for n = 0 to 3 where val in
    each case corresponds to the appropriate byte in our
    desired 802.1Q tag (0x8100AABB)
9 - Check whether ext[n] for n = 0 to 3 match the desired
    802.1Q tag (0x8100AABB)
10 - Push 12 elements into ext
10 - Use modify_field(ext[n], ext_cpy[n]) for n = 0 to 19
11 - Check whether ext[n] for n = 13 to 16 still match the
     desired 802.1Q tag (0x8100AABB)

Checks:
2: failure = issue with copy_header
   test: success; no issue with copy_header
5: failure = issue with pop (or perhaps parallel semantics
   issue if one of a, b works and the other doesn't)
   test: fail.  Both a and b.  Indicates issue is with
   pop semantics; headers are not being invalidated properly.
9: failure = probably programmer error with byte order; I
   really don't expect this to fail
11: failure = failure with modify_field
