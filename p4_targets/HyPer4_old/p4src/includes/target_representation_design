target metadata:

header_type tmeta_t {
  fields {
    field0 : 8;
    field1 : 8;
    field2 : 16;
    field3 : 4;
    field4 : 4;
  }
}

header tmeta_t tmeta;
header tmeta_t tmeta2;

requirements: make HyPer4 able to do:

for x in range(0,5)
modify_field(tmeta.fieldx, standard_metadata.<field>);
modify_field(standard_metadata.<field>, tmeta.fieldx);
modify_field(tmeta.fieldx, funcparam);
modify_field(tmeta.fieldx, tmeta2.fieldx);
modify_field(tmeta.fieldx, const);

options:
- use HyPer4 registers
- use HyPer4 metadata
- use HyPer4 packet headers

##### HyPer4 registers #####

modify_field(tmeta.field1, standard_metadata.<field>):

The solution involves assigning every primitive action in
the target program a UID, which can be based entirely on
the compound action and the line number of the primitive
action relative to the start of the compound action.  We
don't need to use a table ID as part of the primitive UID.

To represent a target table in HyPer4, we first provide a HyPer4 table
that does the match the target table would.  But the action is to first
set the primitive UID.  The next table can match on the primitive UID
and direct execution flow to the table corresponding to the primitive
control function.  Each primitive control function could theoretically
do things differently, but as currently implemented for modify_field,
the first step is to apply a table that matches on the primitive UID
to set the primitive subtype, addressing information to locate the
destination and/or source data, if necessary, and any other
fields that together, fully indicate how the primitive is to be
executed.  Finally, we apply a table that matches on, at a minimum,
the subtype (other possibilities include the size of the fields
involved, in bytes) and execute the corresponding specific version
of the primitive.

##### HyPer4 metadata #####

##### HyPer4 packet headers #####
