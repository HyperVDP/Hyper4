#!/usr/bin/python

from p4_hlir.main import HLIR
import p4_hlir
from p4_hlir.hlir.p4_core import p4_enum
from collections import OrderedDict
import argparse
import code

parser = argparse.ArgumentParser(description='HP4 Compiler')
parser.add_argument('input', help='path for input .p4',
                    type=str)
parser.add_argument('-o', '--output', help='path for output .hp4t file',
                    type=str, action="store", required=True)

args = parser.parse_args()

p4_match_types = p4_enum.collection['p4_match_type']

class HP4_Command:
  def __init__(self, command, table, action, mparams, aparams):
    self.command = command
    self.table = table
    self.action = action
    self.match_params = mparams
    self.action_params = aparams
  def __str__(self):
    ret = self.command + ' ' + self.table + ' ' + self.action
    for param in self.match_params:
      ret += ' ' + param
    ret += ' =>'
    for param in self.action_params:
      ret += ' ' + param

class HP4C:
  def __init__(self, h):
    self.actionUIDs = {}
    self.tables = OrderedDict()
    self.actioncounter = 0
    self.tablecounter = 0
    self.bits_needed_explicit = {}
    self.bits_needed_total = {}
    self.h = h
    self.h.build()
    if len(self.h.p4_ingress_ptr) > 1:
      print("ERROR: multiple ingress entry points:")
      for node in h.p4_ingress_ptr.keys():
        print('  ' + node)
      exit()        

  """
  def collectParseNodes(self):
    if 'start' not in self.h.p4_parse_states:
      print("ERROR: Could not find \'start\' in parse_states")
      exit()
    start = self.h.p4_parse_states['start']
    for call in start.call_sequence:
      if call[0][0].value not 'extract':
        print("ERROR: %s parser call not yet supported" % call[0][0].value)
        exit()

  total = 0
  bits_extracted = 20*8
  extract_more = {}

  def collectParseNodes(self, node, state):
    for call in node.call_sequence:
      if call[0].value not 'extract':
        print("ERROR: unsupported call %s" % call[0].value)
        exit()
      for field in call[1].fields:
        total += field.width
    if total > bits_extracted:
      # register need to extract_more
      extract_more[(node.name, state)] = total
    else:
      extract_more[(node.name, state)] = 0
  """
  def collectParseNodes(self):
    pass

  """
  - We must assign a pc.state to each parse function.  '0' for start.
  - Determine bit requirements for each path (inc. partial paths) through the parse tree:
    explicit = {(pc.state, [start, ..., state immediately preceding pc.state]): numbits}
    total = {(pc.state, [start, ..., state immediately preceding pc.state]): numbits}
    # 'total' includes current(X, Y)-imposed extraction requirements.
    # Two steps: explicit -> total
    # Start at 'start'.  E.g., exp_parse_tree_traverse(h.p4_parse_states['start'], [], 0)
    # Then total_parse_tree_traverse(h.p4_parse_states['start'], [])
  - Use total to populate {(pc.state, numbits): next_numbits} dictionary
  """  
  def collectParseStatesBitsNeeded(self):
    self.exp_parse_tree_traverse(self.h.p4_parse_states['start'], [], 0)
    self.total_parse_tree_traverse(self.h.p4_parse_states['start'], [])
    # Next comes one more tricky part: building the {(state, numbits): next_numbits}
    # dictionary.  numbits in that tuple refers to the value coming INTO the state -
    # i.e., the number of bits extracted immediately prior to state.  next_numbits
    # comes directly from bits_needed_total.
    # Maybe easiest solution is to sift through bits_needed_total - can use the list
    # in the key's tuple of preceding states, for each state in that list look at
    # number of entries in bits_needed_total for which the state in the key's tuple
    # is a match

  def exp_parse_tree_traverse(self, state, preceding_states, so_far):
    numbits = so_far
    
    # collect total number of bits to extract in the state
    for call in state.call_sequence:
      if call[0].value != 'extract':
        print("ERROR: unsupported call %s" % call[0].value)
        exit()
      for key in call[1].header_type.layout.keys():
        numbits += call[1].header_type.layout[key]
    self.bits_needed_explicit[(state, preceding_states)] = numbits

    # collect next states
    next_states = []
    if state.return_statement[0] == 'immediate':
      if state.return_statement[1] != 'ingress':
        next_states.append(self.h.p4_parse_states[state.return_statement[1]])
      else:
        return
    elif state.return_statement[0] == 'select':
      for case in state.return_statement[2]:
        key = case[1]
        if key != 'ingress':
          next_states.append(self.h.p4_parse_states[key])
    else:
      print("ERROR: Unknown directive in return statement: %s" % state.return_statement[0])
      exit()

    # recurse for every next state reachable from this state
    for next_state in next_states:
      next_preceding_states = preceding_states
      next_preceding_states.append(next_state)
      exp_parse_tree_traverse(next_state, next_preceding_states, numbits)

  def total_parse_tree_traverse(self, state, preceding_states):
    numbits = self.bits_needed_explicit[(state, preceding_states)]
    next_states = []

    # first handle trivial case; no 'current' because return type is immediate
    if state.return_statement[0] == 'immediate':
      if state.return_statement[1] != 'ingress':
        next_states.append(self.h.p4_parse_states[state.return_statement[1]])
      else:
        return
    elif state.return_statement[0] == 'select':
      maxcurr = 0
      for criteria in state.return_statement[1]:
        # look for 'current' instances, represented as tuples in HLIR
        if isinstance(criteria, tuple):
          if criteria[0] + criteria[1] > maxcurr:
            maxcurr = criteria[0] + criteria[1]
      numbits += maxcurr
      
    else:
      print("ERROR: Unknown directive in return statement: %s" % state.return_statement[0])
      exit()

    self.bits_needed_total[(state, preceding_states)] = numbits
    
    # recurse for every next state reachable from this state
    for next_state in next_states:
      next_preceding_states = preceding_states
      next_preceding_states.append(next_state)
      total_parse_tree_traverse(next_state, next_preceding_states)

  def collectActions(self):
    for table in self.h.p4_tables.values():
      for action in table.actions:
        if action not in self.actionUIDs:
          self.actioncounter += 1
          self.actionUIDs[action] = self.actioncounter

  # if first.match_fields[0][1] == p4_match_types.P4_MATCH_EXACT:

  # credit: http://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis/
  def collectTables(self):
    visited = set()
    order = []
    
    def dfs_walk(node):
      if node:
        visited.add(node)
        for i in range(len(node.next_)):
          succ = node.next_[node.next_.keys()[i]]
          if not succ in visited:
            dfs_walk(succ)
        if isinstance(node, p4_hlir.hlir.p4_tables.p4_conditional_node):
          print("ERROR: conditional nodes not yet supported")
          exit()
        if len(node.match_fields) > 1:
          print("ERROR: multiple match fields (%s) not yet supported" % first.name)
          exit()
        order.append(node)

    dfs_walk(self.h.p4_ingress_ptr.keys()[0])   
    order.reverse()
    for table in order:
      self.tablecounter += 1
      self.tables[table] = self.tablecounter
  
  def printTables(self):
    for table in self.tables.keys():
      print(table.name)

def main():
  hp4compiler = HP4C(HLIR(args.input))
  hp4compiler.collectParseNodes()
  hp4compiler.collectActions()
  hp4compiler.collectTables()
  hp4compiler.collectParseStatesBitsNeeded()
  hp4compiler.printTables()
  # code.interact(local=locals())

if __name__ == '__main__':
  main()
